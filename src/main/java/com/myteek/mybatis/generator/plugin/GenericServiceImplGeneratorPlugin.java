package com.myteek.mybatis.generator.plugin;

import com.myteek.mybatis.constant.Constants;
import com.myteek.mybatis.generator.util.Util;
import org.mybatis.generator.api.GeneratedJavaFile;
import org.mybatis.generator.api.IntrospectedColumn;
import org.mybatis.generator.api.IntrospectedTable;
import org.mybatis.generator.api.JavaFormatter;
import org.mybatis.generator.api.PluginAdapter;
import org.mybatis.generator.api.ShellCallback;
import org.mybatis.generator.api.dom.java.CompilationUnit;
import org.mybatis.generator.api.dom.java.Field;
import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType;
import org.mybatis.generator.api.dom.java.InnerClass;
import org.mybatis.generator.api.dom.java.JavaVisibility;
import org.mybatis.generator.api.dom.java.Method;
import org.mybatis.generator.api.dom.java.Parameter;
import org.mybatis.generator.api.dom.java.TopLevelClass;
import org.mybatis.generator.exception.ShellException;
import org.mybatis.generator.internal.DefaultShellCallback;
import org.mybatis.generator.internal.util.StringUtility;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class GenericServiceImplGeneratorPlugin extends PluginAdapter {

    private static final Logger logger = LoggerFactory.getLogger(GenericServiceImplGeneratorPlugin.class);

    private String serviceTargetDir;
    private String serviceTargetPackage;
    private String mapperTargetPackage;
    private Boolean statement;
    private Boolean isSubPackagesEnabled;

    private ShellCallback shellCallback;

    public GenericServiceImplGeneratorPlugin() {
        this.shellCallback = new DefaultShellCallback(false);
    }

    @Override
    public boolean validate(List<String> list) {
        String serviceTargetDir = this.properties.getProperty("serviceTargetDir");
        this.serviceTargetDir = serviceTargetDir;
        String serviceTargetPackage = this.properties.getProperty("serviceTargetPackage");
        this.serviceTargetPackage = serviceTargetPackage;
        this.mapperTargetPackage = this.properties.getProperty("mapperTargetPackage");
        String statement = this.properties.getProperty("statement");
        statement = !StringUtility.stringHasValue(statement) ? "true" : statement;
        this.statement = Boolean.valueOf(statement);
        String enableSubPackages = this.properties.getProperty("enableSubPackages");
        enableSubPackages = !StringUtility.stringHasValue(enableSubPackages) ? "false" : enableSubPackages;
        this.isSubPackagesEnabled = Boolean.valueOf(enableSubPackages);
        return StringUtility.stringHasValue(serviceTargetDir) && StringUtility.stringHasValue(serviceTargetPackage);
    }

    @Override
    public List<GeneratedJavaFile> contextGenerateAdditionalJavaFiles(IntrospectedTable introspectedTable) {
        ArrayList<GeneratedJavaFile> mapperJavaFiles = new ArrayList<>();
        JavaFormatter javaFormatter = this.context.getJavaFormatter();

        List<IntrospectedColumn> primaryKeyColumns = introspectedTable.getPrimaryKeyColumns();

        String packageName = introspectedTable.getFullyQualifiedTable().getSubPackageForModel(isSubPackagesEnabled);

        Iterator<GeneratedJavaFile> javaFilesIterator = introspectedTable.getGeneratedJavaFiles().iterator();
        while (javaFilesIterator.hasNext()) {
            GeneratedJavaFile javaFile = javaFilesIterator.next();
            CompilationUnit unit = javaFile.getCompilationUnit();
            FullyQualifiedJavaType modelJavaType = unit.getType();
            String shortName = modelJavaType.getShortName();
            if (shortName.equals(introspectedTable.getFullyQualifiedTable().getDomainObjectName()) &&
                    !shortName.endsWith("Example") && !shortName.endsWith("Mapper") &&
                    !shortName.endsWith("SqlProvider")
            ) {
                String serviceName = shortName + "ServiceImpl";
                TopLevelClass serviceImplClass = new TopLevelClass(this.serviceTargetPackage +
                        packageName + ".impl." + serviceName
                );
                serviceImplClass.setVisibility(JavaVisibility.PUBLIC);

                serviceImplClass.addJavaDocLine("/**");
                serviceImplClass.addJavaDocLine(" * ServiceImpl: " + serviceName);
                serviceImplClass.addJavaDocLine(" * Mapper : " + shortName + "Mapper");
                serviceImplClass.addJavaDocLine(" * Model  : " + shortName);
                serviceImplClass.addJavaDocLine(
                        " * This ServiceImpl generated by MyBatis Generator Extend at " + Util.now()
                );
                serviceImplClass.addJavaDocLine(" */");

                FullyQualifiedJavaType mapperType = new FullyQualifiedJavaType(mapperTargetPackage +
                        packageName + "." + shortName + "Mapper"
                );
                serviceImplClass.addImportedType(mapperType);

                Field mapperField = new Field(Util.convertLowerFieldName(shortName) + "Mapper", mapperType);
                mapperField.setVisibility(JavaVisibility.PRIVATE);
                FullyQualifiedJavaType autowired = new FullyQualifiedJavaType(Constants.AUTOWIRED_CLASS_PATH);
                mapperField.addAnnotation("@Autowired");
                serviceImplClass.addImportedType(autowired);

                if (statement) {
                    FullyQualifiedJavaType service = new FullyQualifiedJavaType(Constants.SERVICE_CLASS_PATH);
                    FullyQualifiedJavaType transactional = new FullyQualifiedJavaType(
                            Constants.TRANSACTIONAL_CLASS_PATH
                    );
                    serviceImplClass.addImportedType(service);
                    serviceImplClass.addImportedType(transactional);
                    serviceImplClass.addAnnotation("@Service");
                    serviceImplClass.addAnnotation("@Transactional");
                }

                serviceImplClass.addField(mapperField);
                serviceImplClass.addImportedType(modelJavaType);

                if (primaryKeyColumns.size() > 0) {
                    FullyQualifiedJavaType pkType = primaryKeyColumns.size() > 1 ?
                            ((InnerClass) unit).getSuperClass().get() :
                            primaryKeyColumns.get(0).getFullyQualifiedJavaType();

                    FullyQualifiedJavaType superImplType = new FullyQualifiedJavaType(
                            Constants.GENERIC_SERVICE_IMPL_CLASS_PATH
                    );
                    superImplType.addTypeArgument(modelJavaType);
                    if (primaryKeyColumns.size() == 1) {
                        superImplType.addTypeArgument(pkType);
                    } else {
                        superImplType.addTypeArgument(
                                new FullyQualifiedJavaType(introspectedTable.getPrimaryKeyType()));
                    }
                    superImplType.addTypeArgument(mapperType);
                    serviceImplClass.addImportedType(superImplType);
                    serviceImplClass.setSuperClass(superImplType);

                } else {
                    FullyQualifiedJavaType superImplType = new FullyQualifiedJavaType(
                            Constants.GENERIC_WITHOUT_PRIMARY_KEY_SERVICE_IMPL_CLASS_PATH
                    );
                    serviceImplClass.addImportedType(superImplType);
                    superImplType.addTypeArgument(modelJavaType);
                    superImplType.addTypeArgument(mapperType);
                    serviceImplClass.setSuperClass(superImplType);
                }

                FullyQualifiedJavaType interfaceType = new FullyQualifiedJavaType(
                        this.serviceTargetPackage + packageName + "." + shortName + "Service"
                );
                serviceImplClass.addImportedType(interfaceType);
                serviceImplClass.addSuperInterface(interfaceType);

                // get generic mapper
                Method mapperMethod = new Method("getGenericMapper");
                mapperMethod.addBodyLine("return " + mapperField.getName() + ";");
                mapperMethod.setVisibility(JavaVisibility.PUBLIC);
                mapperMethod.addAnnotation("@Override");
                mapperMethod.setReturnType(mapperType);
                serviceImplClass.addMethod(mapperMethod);

                if (primaryKeyColumns.size() == 1) {
                    serviceImplClass.addImportedType("java.util.Objects");
                    // checkExistsAndGet
                    Method checkExistsAndGet = new Method("checkExistsAndGet");
                    checkExistsAndGet.addParameter(
                            new Parameter(primaryKeyColumns.get(0).getFullyQualifiedJavaType(), "id"));
                    checkExistsAndGet.addBodyLine(shortName + " ret = null;");
                    checkExistsAndGet.addBodyLine("if (Objects.nonNull(id)) {");
                    checkExistsAndGet.addBodyLine("ret = " +
                            mapperField.getName() + ".selectByPrimaryKey(id);");
                    checkExistsAndGet.addBodyLine("}");
                    checkExistsAndGet.addBodyLine("return ret;");
                    checkExistsAndGet.setVisibility(JavaVisibility.PUBLIC);
                    checkExistsAndGet.addAnnotation("@Override");
                    checkExistsAndGet.setReturnType(modelJavaType);
                    serviceImplClass.addMethod(checkExistsAndGet);
                }

                try {
                    GeneratedJavaFile file = new GeneratedJavaFile(serviceImplClass,
                            this.serviceTargetDir, javaFormatter
                    );
                    // 获取当前项目目录
                    File mapperDir = this.shellCallback.getDirectory(this.serviceTargetDir,
                            this.serviceTargetPackage + packageName + ".impl"
                    );
                    File mapperFile = new File(mapperDir, file.getFileName());
                    if (!mapperFile.exists()) {
                        mapperJavaFiles.add(file);
                    }
                } catch (ShellException e) {
                    logger.error("Get directory error!", e);
                }
            }
        }
        return mapperJavaFiles;
    }

}
